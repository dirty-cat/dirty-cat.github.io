
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>dirty_cat._fuzzy_join &#8212; &amp;mdash; Dirty cat</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-rendered-html.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/scrolltoc.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><!--
    Inherited from the original Alabaster theme:
    https://github.com/bitprophet/alabaster/blob/master/alabaster/about.html
    Only the "Version" number is added.
-->

<p class="logo">
  <a href="../../index.html">
    <img class="logo" src="../../_static/dirty_cat.svg" alt="Logo"/>
    
    <h1 class="logo logo-name">dirty_cat</h1>
    
  </a>
  <div class="version-switcher">
    <h4>Version 0.4.dev0</h4>
    <details>
	<summary>Other versions</summary>
	<ul>
	    <li><a href="https://dirty-cat.github.io/stable">Stable</a></li>
	    <li><a href="https://dirty-cat.github.io/dev">Dev</a></li>
	</ul>
    </details>
  </div>
</p>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=dirty-cat&repo=dirty_cat&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<ul>
    <li class="toctree-l1"><a href="../../index.html#using-dirty-cat">Usage</a></li>
    <li class="toctree-l1"><a href="../../index.html#api-documentation">API</a></li>
    <li class="toctree-l1"><a href="../../index.html#about">About</a></li>
</ul><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for dirty_cat._fuzzy_join</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Fuzzy joining tables using string columns.</span>
<span class="sd">The principle is as follows:</span>
<span class="sd">  1. We embed and transform the key string columns using CountVectorizer</span>
<span class="sd">  and TfifdTransformer.</span>
<span class="sd">  2. For each category, we use the nearest neighbor method to find its closest</span>
<span class="sd">  neighbor and establish a match.</span>
<span class="sd">  3. We match the tables using the previous information.</span>
<span class="sd">Categories from the two tables that share many sub-strings (n-grams)</span>
<span class="sd">have greater probability of beeing matched together. The join is based on</span>
<span class="sd">morphological similarities between strings.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">vstack</span>
<span class="kn">from</span> <span class="nn">sklearn.feature_extraction.text</span> <span class="kn">import</span> <span class="n">CountVectorizer</span><span class="p">,</span> <span class="n">TfidfTransformer</span>
<span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">NearestNeighbors</span>


<div class="viewcode-block" id="fuzzy_join"><a class="viewcode-back" href="../../generated/dirty_cat.fuzzy_join.html#dirty_cat.fuzzy_join">[docs]</a><span class="k">def</span> <span class="nf">fuzzy_join</span><span class="p">(</span>
    <span class="n">left</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">right</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">left_on</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">right_on</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">on</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">how</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span><span class="p">,</span>
    <span class="n">return_score</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">analyzer</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;word&quot;</span><span class="p">,</span> <span class="s2">&quot;char&quot;</span><span class="p">,</span> <span class="s2">&quot;char_wb&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;char_wb&quot;</span><span class="p">,</span>
    <span class="n">ngram_range</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
    <span class="n">match_score</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">drop_unmatched</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">suffixes</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;_l&quot;</span><span class="p">,</span> <span class="s2">&quot;_r&quot;</span><span class="p">),</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Join two tables categorical string columns based on approximate</span>
<span class="sd">    matching and using morphological similarity.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    left : pandas.DataFrame</span>
<span class="sd">        A table to merge.</span>
<span class="sd">    right : pandas.DataFrame</span>
<span class="sd">        A table used to merge with.</span>
<span class="sd">    left_on : typing.Union[str, None]</span>
<span class="sd">        Name of left table column to join.</span>
<span class="sd">    right_on : typing.Union[str, None]</span>
<span class="sd">        Name of right table key column to join</span>
<span class="sd">        with left table key column.</span>
<span class="sd">    on : typing.Union[str, None]</span>
<span class="sd">        Name of common left and right table join key columns.</span>
<span class="sd">        Must be found in both DataFrames. Use only if `left_on`</span>
<span class="sd">        and `right_on` parameters are not specified.</span>
<span class="sd">    how : typing.Literal[&#39;left&#39;, &#39;right&#39;, &#39;all&#39;], default=&#39;all&#39;</span>
<span class="sd">        Keep the join key columns from the left, right or</span>
<span class="sd">        all tables.</span>
<span class="sd">    return_score : boolean, default=True</span>
<span class="sd">        Wheter to return matching score based on the distance between</span>
<span class="sd">        nearest matched categories.</span>
<span class="sd">    analyzer : typing.Literal[&quot;word&quot;, &quot;char&quot;, &quot;char_wb&quot;], default=`char_wb`</span>
<span class="sd">        Analyzer parameter for the CountVectorizer used for the string</span>
<span class="sd">        similarities.</span>
<span class="sd">        Options: {`word`, `char`, `char_wb`}, describing whether the matrix V</span>
<span class="sd">        to factorize should be made of word counts or character n-gram counts.</span>
<span class="sd">        Option `char_wb` creates character n-grams only from text inside word</span>
<span class="sd">        boundaries; n-grams at the edges of words are padded with space.</span>
<span class="sd">    ngram_range : tuple (min_n, max_n), default=(2, 4)</span>
<span class="sd">        The lower and upper boundary of the range of n-values for different</span>
<span class="sd">        n-grams used in the string similarity. All values of n such</span>
<span class="sd">        that min_n &lt;= n &lt;= max_n will be used.</span>
<span class="sd">    match_score : float, default=0</span>
<span class="sd">        Distance score between the closest matches that will be accepted.</span>
<span class="sd">        In a [0, 1] interval. Closer to 1 means the matches need to be very</span>
<span class="sd">        close to be accepted, and closer to 0 that a bigger matching distance</span>
<span class="sd">        is tolerated.</span>
<span class="sd">    drop_unmatched : boolean, default=False</span>
<span class="sd">        Remove categories for which a match was not found in the two tables.</span>
<span class="sd">    suffixes : typing.Tuple[str, str], default=(&#39;_x&#39;, &#39;_y&#39;)</span>
<span class="sd">        A list of strings indicating the suffix to add when overlaping</span>
<span class="sd">        column names.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    df_joined: pandas.DataFrame</span>
<span class="sd">        The joined table returned as a DataFrame. If `return_score` is True,</span>
<span class="sd">        another column will be added to the DataFrame containing the</span>
<span class="sd">        matching scores.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    When return_score=True, the returned DataFrame gives</span>
<span class="sd">    the distances between closest matches in a [0, 1] interval.</span>
<span class="sd">    0 corresponds to no matching n-grams, while 1 is a</span>
<span class="sd">    perfect match.</span>

<span class="sd">    When we use `match_score=0`, the function will be forced to impute the</span>
<span class="sd">    nearest match (of the left table category) across all possible matching</span>
<span class="sd">    options in the right table column.</span>

<span class="sd">    When the neighbors are distant, we may use the `match_score` parameter</span>
<span class="sd">    with a value bigger than 0 to define the minimal level of matching</span>
<span class="sd">    score tolerated. If it is not reached, matches will be</span>
<span class="sd">    considered as not found and NaN values will be imputed.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; df1 = pd.DataFrame({&#39;a&#39;: [&#39;ana&#39;, &#39;lala&#39;, &#39;nana&#39;], &#39;b&#39;: [1, 2, 3]})</span>
<span class="sd">    &gt;&gt;&gt; df2 = pd.DataFrame({&#39;a&#39;: [&#39;anna&#39;, &#39;lala&#39;, &#39;ana&#39;, &#39;sana&#39;], &#39;c&#39;: [5, 6, 7, 8]})</span>

<span class="sd">    &gt;&gt;&gt; df1</span>
<span class="sd">        a  b</span>
<span class="sd">    0   ana  1</span>
<span class="sd">    1  lala  2</span>
<span class="sd">    2  nana  3</span>

<span class="sd">    &gt;&gt;&gt; df2</span>
<span class="sd">        a  c</span>
<span class="sd">    0  anna  5</span>
<span class="sd">    1  lala  6</span>
<span class="sd">    2   ana  7</span>
<span class="sd">    3  sana  8</span>

<span class="sd">    To do a simple join based on the nearest match:</span>

<span class="sd">    &gt;&gt;&gt; fuzzy_join(df1, df2, on=&#39;a&#39;)</span>
<span class="sd">        a_l  b   a_r    c</span>
<span class="sd">    0   ana  1   ana   7</span>
<span class="sd">    1  lala  2  lala   6</span>
<span class="sd">    2  nana  3  sana   8</span>

<span class="sd">    When we want to accept only a certain match precison,</span>
<span class="sd">    we can use the `match_score` argument:</span>

<span class="sd">    &gt;&gt;&gt; fuzzy_join(df1, df2, on=&#39;a&#39;, match_score=1, return_score=True)</span>
<span class="sd">        a_l  b   a_r    c  matching_score</span>
<span class="sd">    0   ana  1   ana  7.0  1.000000</span>
<span class="sd">    1  lala  2  lala  6.0  1.000000</span>
<span class="sd">    2  nana  3   NaN  NaN  0.532717</span>

<span class="sd">    As expected, the category &quot;nana&quot; has no exact match (`match_score=1`).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;This feature is still experimental.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">analyzer</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;char&quot;</span><span class="p">,</span> <span class="s2">&quot;word&quot;</span><span class="p">,</span> <span class="s2">&quot;char_wb&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;analyzer should be either &#39;char&#39;, &#39;word&#39; or &#39;char_wb&#39;, got </span><span class="si">{</span><span class="n">analyzer</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">how</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;how should be either &#39;left&#39;, &#39;right&#39; or &#39;all&#39;, got </span><span class="si">{</span><span class="n">how</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">suffixes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid number of suffixes: expected 2, got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">suffixes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">lsuffix</span><span class="p">,</span> <span class="n">rsuffix</span> <span class="o">=</span> <span class="n">suffixes</span>

    <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="p">[</span><span class="n">on</span><span class="p">,</span> <span class="n">left_on</span><span class="p">,</span> <span class="n">right_on</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">param</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Parameter &#39;left_on&#39;, &#39;right_on&#39; or &#39;on&#39; has invalid type, expected&quot;</span>
                <span class="s2">&quot; string&quot;</span>
            <span class="p">)</span>

    <span class="n">left_table_clean</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">right_table_clean</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">overlap_cols</span> <span class="o">=</span> <span class="n">left_table_clean</span><span class="o">.</span><span class="n">_info_axis</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span>
        <span class="n">right_table_clean</span><span class="o">.</span><span class="n">_info_axis</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">overlap_cols</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">suffixes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="ow">and</span> <span class="n">suffixes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Columns overlap but no suffix specified: </span><span class="si">{</span><span class="n">overlap_cols</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">overlap_cols</span><span class="p">)):</span>
            <span class="n">new_name_l</span> <span class="o">=</span> <span class="n">overlap_cols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">lsuffix</span>
            <span class="n">new_name_r</span> <span class="o">=</span> <span class="n">overlap_cols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">rsuffix</span>
            <span class="n">left_table_clean</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">overlap_cols</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">new_name_l</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">right_table_clean</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
                <span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">overlap_cols</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">new_name_r</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">left_on</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">overlap_cols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">left_on</span><span class="p">:</span>
                <span class="n">left_on</span> <span class="o">=</span> <span class="n">new_name_l</span>
            <span class="k">if</span> <span class="n">right_on</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">overlap_cols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">right_on</span><span class="p">:</span>
                <span class="n">right_on</span> <span class="o">=</span> <span class="n">new_name_r</span>

    <span class="k">if</span> <span class="n">on</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">left_col</span> <span class="o">=</span> <span class="n">on</span> <span class="o">+</span> <span class="n">lsuffix</span>
        <span class="n">right_col</span> <span class="o">=</span> <span class="n">on</span> <span class="o">+</span> <span class="n">rsuffix</span>
    <span class="k">elif</span> <span class="n">left_on</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">right_on</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">left_col</span> <span class="o">=</span> <span class="n">left_on</span>
        <span class="n">right_col</span> <span class="o">=</span> <span class="n">right_on</span>

    <span class="c1"># Drop missing values in key columns</span>
    <span class="n">left_table_clean</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="n">left_col</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">right_table_clean</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="n">right_col</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Make sure that the column types are string and categorical:</span>
    <span class="n">left_table_clean</span><span class="p">[</span><span class="n">left_col</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">left_table_clean</span><span class="p">[</span><span class="n">left_col</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;category&quot;</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">right_table_clean</span><span class="p">[</span><span class="n">right_col</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">right_table_clean</span><span class="p">[</span><span class="n">right_col</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;category&quot;</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">enc</span> <span class="o">=</span> <span class="n">CountVectorizer</span><span class="p">(</span><span class="n">analyzer</span><span class="o">=</span><span class="n">analyzer</span><span class="p">,</span> <span class="n">ngram_range</span><span class="o">=</span><span class="n">ngram_range</span><span class="p">)</span>

    <span class="n">all_cats</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
        <span class="p">[</span><span class="n">left_table_clean</span><span class="p">[</span><span class="n">left_col</span><span class="p">],</span> <span class="n">right_table_clean</span><span class="p">[</span><span class="n">right_col</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
    <span class="p">)</span>

    <span class="n">enc_cv</span> <span class="o">=</span> <span class="n">enc</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">all_cats</span><span class="p">)</span>
    <span class="n">left_enc</span> <span class="o">=</span> <span class="n">enc_cv</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">left_table_clean</span><span class="p">[</span><span class="n">left_col</span><span class="p">])</span>
    <span class="n">right_enc</span> <span class="o">=</span> <span class="n">enc_cv</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">right_table_clean</span><span class="p">[</span><span class="n">right_col</span><span class="p">])</span>

    <span class="n">all_enc</span> <span class="o">=</span> <span class="n">vstack</span><span class="p">((</span><span class="n">left_enc</span><span class="p">,</span> <span class="n">right_enc</span><span class="p">))</span>

    <span class="n">tfidf</span> <span class="o">=</span> <span class="n">TfidfTransformer</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">all_enc</span><span class="p">)</span>
    <span class="n">left_enc</span> <span class="o">=</span> <span class="n">tfidf</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">left_enc</span><span class="p">)</span>
    <span class="n">right_enc</span> <span class="o">=</span> <span class="n">tfidf</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">right_enc</span><span class="p">)</span>

    <span class="c1"># Find nearest neighbor using KNN :</span>
    <span class="n">neigh</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">neigh</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">right_enc</span><span class="p">)</span>
    <span class="n">distance</span><span class="p">,</span> <span class="n">neighbors</span> <span class="o">=</span> <span class="n">neigh</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">left_enc</span><span class="p">,</span> <span class="n">return_distance</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">idx_closest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span>

    <span class="n">norm_distance</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">distance</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">left_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">left_table_clean</span><span class="p">)</span>
    <span class="n">right_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">right_table_clean</span><span class="p">)</span>
    <span class="n">joined</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="n">left_array</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">right_array</span><span class="p">[</span><span class="n">idx_closest</span><span class="p">[</span><span class="n">idr</span><span class="p">]]</span>
                <span class="k">if</span> <span class="n">norm_distance</span><span class="p">[</span><span class="n">idr</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">match_score</span>
                <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="p">(</span><span class="n">right_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],))</span>
                <span class="k">for</span> <span class="n">idr</span> <span class="ow">in</span> <span class="n">left_table_clean</span><span class="o">.</span><span class="n">index</span>
            <span class="p">]</span>
        <span class="p">),</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">left_table_clean</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">right_table_clean</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
    <span class="n">df_joined</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">joined</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">cols</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^\s*$&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">duplicate_names</span> <span class="o">=</span> <span class="n">df_joined</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">duplicate_names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Column names overlaps. Please set appropriate suffixes.&quot;</span><span class="p">)</span>
        <span class="n">idx_to_keep</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">duplicate_names</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">return_score</span><span class="p">:</span>
        <span class="n">df_joined</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
            <span class="p">[</span><span class="n">df_joined</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">norm_distance</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;matching_score&quot;</span><span class="p">])],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">drop_unmatched</span><span class="p">:</span>
        <span class="n">df_joined</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="n">left_col</span><span class="p">,</span> <span class="n">right_col</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">duplicate_names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">idx_to_keep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">duplicate_names</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">idx_to_keep</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="n">df_joined</span> <span class="o">=</span> <span class="n">df_joined</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">idx_to_keep</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df_joined</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="n">right_col</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;right&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">duplicate_names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">idx_to_keep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">duplicate_names</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">idx_to_keep</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="n">df_joined</span> <span class="o">=</span> <span class="n">df_joined</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">idx_to_keep</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df_joined</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="n">left_col</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df_joined</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2018-2021, dirty_cat developers.
      
    </div>

    

    
  </body>
</html>